# v0.2.8 工业级进化规划：对标 Cursor 的专业原生 AI 编辑器

## 核心目标
从“对话辅助”模式进化为“深度上下文感知 + 全栈协同编辑”模式。

## 商业/社区版分发策略
- **商业版 (`--features commercial`):** 
  - 实现基于 `tree-sitter` 的深度符号索引。
  - 实现基于事务的文件原子操作与回滚。
  - 提供多文件 Diff 预览与智能合并逻辑。
- **社区版 (`default`):**
  - 使用标准的 `grep` 搜索作为兜底。
  - 文件写入为非原子操作（即目前的 `agent_write_file`）。
  - AI 响应不包含多文件同步重构建议。

## 场景一：符号感知 RAG (Symbol-Aware Context)
### 目标
验证 AI 是否真正“理解”代码结构，而非简单的文本匹配。

| 用例 ID | 测试类型 | 场景描述 | 预期结果 (Expected) |
| :--- | :--- | :--- | :--- |
| **RAG-001** | Unit (Rust) | 解析包含嵌套 Struct 和 Trait 的 Rust 文件 | `tree-sitter` 准确提取所有定义及其所在行号。 |
| **RAG-002** | Unit (Rust) | 跨文件符号关联：查询 A 文件中的类，在 B 文件中找到引用 | 索引索引能准确建立 `Symbol(A) -> References([B, C])` 的链路。 |
| **RAG-003** | E2E | 用户询问：“这个 Trait 有哪些具体实现？” | AI 响应中必须列出所有实现类的文件路径，而非相似的注释文本。 |
| **RAG-004** | E2E | @代码库 提问：“修改 `RagService` 会影响哪些模块？” | AI 能够识别出依赖该接口的所有上层 Service 和 Command 包装器。 |

## 场景二：Composer 2.0 (原子级多文件协同)
### 目标
模拟复杂重构任务，确保多文件修改的一致性。

| 用例 ID | 测试类型 | 场景描述 | 预期结果 (Expected) |
| :--- | :--- | :--- | :--- |
| **CMP-001** | Unit (Rust) | 原子写入逻辑：模拟写入 3 个文件，第 2 个失败 | 系统自动触发回滚，已修改的第 1 个文件恢复原状。 |
| **CMP-002** | E2E | 场景重构：给 `User` 模型增加字段，并同步更新 API 和 UI | UI 弹出 **Multi-file Diff 预览**，展示 3 个文件的变更对比。 |
| **CMP-003** | E2E | 局部采纳：用户在 Diff 预览中只点击“接受文件 A”，拒绝“文件 B” | 只有文件 A 被持久化到磁盘，文件 B 保持不变。 |
| **CMP-004** | E2E | 冲突检测：AI 尝试修改一个用户正在手动编辑的文件 | 系统提示“文件已变更”，并要求用户确认合并。 |

## 场景三：智能终端闭环 (Smart Terminal Loop)
### 目标
验证“发现错误 -> 理解错误 -> 修复错误”的自动化链路。

| 用例 ID | 测试类型 | 场景描述 | 预期结果 (Expected) |
| :--- | :--- | :--- | :--- |
| **TRM-001** | Unit (Rust) | 错误堆栈解析器：解析 `cargo build` 或 `npm run dev` 的错误输出 | 准确提取出文件名、行号以及 Error Code（如 `E0433`）。 |
| **TRM-002** | E2E | 终端修复：点击报错信息旁的 "Debug with AI" 按钮 | AI 自动载入报错位置的代码上下文，并直接给出修复补丁。 |
| **TRM-003** | E2E | 验证修复：AI 生成修复代码并应用后，自动在终端重跑命令 | 终端显示编译通过，AI 自动关闭修复对话框。 |

## 场景四：原生编辑体验 (Predictive Editing)
### 目标
对标 Cursor 的 `Copilot++` 和 `Cmd+K`。

| 用例 ID | 测试类型 | 场景描述 | 预期结果 (Expected) |
| :--- | :--- | :--- | :--- |
| **EDT-001** | E2E | 行内指令 (Inline Edit)：选中一段代码按下快捷键要求“优化性能” | 代码原地变为 Diff 模式，展示优化前后的差异。 |
| **EDT-002** | Unit (Vitest) | 预测补全：基于当前光标前的 10 行代码和符号索引生成补全建议 | 建议的符号（变量名/方法名）必须在当前作用域内真实存在。 |

## 技术栈准备
- **后端 (Rust):** `tree-sitter`, `lsp-types`, `tokio` (原子文件操作)
- **前端 (TS):** `monaco-editor` (Diff view), `Vitest`
- **E2E:** `Playwright`
