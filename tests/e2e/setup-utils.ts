import { Page } from '@playwright/test';

/**
 * è®¾ç½® E2E æµ‹è¯•ç¯å¢ƒï¼Œå¼ºåŠ›é”å®šåº”ç”¨çŠ¶æ€
 */
export async function setupE2ETestEnvironment(page: Page) {
  // 1. Mock API
  await page.route('**/v1/chat/completions', async (route) => {
    await route.fulfill({
      status: 200,
      contentType: 'application/json',
      body: JSON.stringify({
        id: 'mock-' + Date.now(),
        choices: [{ index: 0, message: { role: 'assistant', content: 'Starting task implementation...' }, finish_reason: 'stop' }],
        usage: { total_tokens: 10 }
      }),
    });
  });

  // 2. æ³¨å…¥æ ¸å¿ƒæ‹¦æˆªä¸é”å®šè„šæœ¬
  await page.addInitScript(() => {
    // A. æ·±åº¦ Mock Tauri with event support
    // Put eventListeners on window so it's accessible from Mock code
    (window as any).__TAURI_EVENT_LISTENERS__ = {};

    // ğŸ”¥ å†…å­˜æ–‡ä»¶ç³»ç»Ÿï¼Œç”¨äºè·Ÿè¸ªæ–‡ä»¶å†…å®¹å’Œå›æ»šæµ‹è¯•
    const mockFileSystem = new Map<string, string>();
    // æš´éœ²åˆ° window ä»¥ä¾¿å…¶ä»–å‡½æ•°å¯ä»¥è®¿é—®
    (window as any).__E2E_MOCK_FILE_SYSTEM__ = mockFileSystem;

    const mockInvoke = async (cmd: string, args?: any) => {
        if (cmd === 'get_git_statuses') return [];
        if (cmd === 'plugin:fs|read_dir') return [
            { name: 'App.tsx', isDirectory: false, isFile: true },
            { name: 'main.tsx', isDirectory: false, isFile: true },
            { name: 'src', isDirectory: true, isFile: false }
        ];
        if (cmd === 'plugin:fs|read_text_file') {
            if (args.path.endsWith('App.tsx')) return 'export function App() { return <div>App</div>; }';
            if (args.path.endsWith('main.tsx')) return 'import { App } from "./App";\nReactDOM.render(<App />, document.body);';
            return '// Mock content';
        }
        if (cmd === 'read_directory') return [
            { name: 'App.tsx', isDirectory: false, isFile: true },
            { name: 'main.tsx', isDirectory: false, isFile: true }
        ];
        if (cmd === 'plugin:dialog|ask') return true;

        // ğŸ”¥ å•†ä¸šç‰ˆ (ifainew-core) ä½¿ç”¨çš„å‘½ä»¤
        if (cmd === 'agent_read_file') {
            console.log('[E2E Mock] agent_read_file:', args);
            const filePath = `${args.rootPath}/${args.relPath}`.replace(/\/\//g, '/');
            const content = mockFileSystem.get(filePath);
            if (content !== undefined) {
                console.log('[E2E Mock] Returning existing file content');
                return content;
            }
            // æ–‡ä»¶ä¸å­˜åœ¨ï¼ŒæŠ›å‡ºé”™è¯¯
            const error = new Error(`File not found: ${filePath}`);
            (error as any).code = 'ENOENT';
            throw error;
        }
        if (cmd === 'agent_write_file') {
            console.log('[E2E Mock] agent_write_file:', args);
            const filePath = `${args.rootPath}/${args.relPath}`.replace(/\/\//g, '/');

            // ğŸ”¥ è·å–åŸå§‹å†…å®¹ï¼ˆå¦‚æœæ–‡ä»¶å·²å­˜åœ¨ï¼‰
            const originalContent = mockFileSystem.get(filePath) || '';

            // ğŸ”¥ å†™å…¥æ–°å†…å®¹åˆ°å†…å­˜æ–‡ä»¶ç³»ç»Ÿ
            mockFileSystem.set(filePath, args.content);

            console.log('[E2E Mock] File updated:', {
                filePath,
                hadOriginalContent: originalContent !== '',
                newContent: args.content.substring(0, 50)
            });

            // è¿”å›åŒ…å«åŸå§‹å†…å®¹çš„ç»“æ„åŒ–æ•°æ®ï¼ˆç”¨äº rollback æµ‹è¯•ï¼‰
            const rollbackData = {
                success: true,
                message: `File written: ${args.relPath}`,
                originalContent: originalContent,  // ğŸ”¥ è¿”å›å®é™…çš„åŸå§‹å†…å®¹
                filePath: filePath,
                timestamp: Date.now()
            };
            return JSON.stringify(rollbackData);
        }
        if (cmd === 'delete_file') {
            console.log('[E2E Mock] delete_file:', args);
            const filePath = args.path;
            mockFileSystem.delete(filePath);
            console.log('[E2E Mock] File deleted from memory:', filePath);
            return { success: true };
        }
        if (cmd === 'execute_bash_command') {
            console.log('[E2E Mock] execute_bash_command:', args);
            return {
                stdout: 'Mock command output',
                stderr: '',
                exitCode: 0
            };
        }

        // Handle launch_agent command for Demo Agent
        if (cmd === 'launch_agent') {
            const agentId = args?.id;
            const eventId = `agent_${agentId}`; // eventId is generated by frontend

            console.log(`[E2E Mock] Launching agent: ${agentId}, eventId: ${eventId}`);

            // Simulate agent execution with delay
            setTimeout(async () => {
                const globalEventListeners = (globalThis as any).__TAURI_EVENT_LISTENERS__ || {};
                console.log(`[E2E Mock] Checking listeners for ${eventId}:`, Object.keys(globalEventListeners));
                console.log(`[E2E Mock] Listeners count for ${eventId}:`, (globalEventListeners[eventId] || []).length);

                // Emit agent status: running
                const statusListeners = globalEventListeners[eventId] || [];
                console.log(`[E2E Mock] Sending status event to ${statusListeners.length} listeners`);

                statusListeners.forEach((fn: Function) => fn({
                    payload: {
                        type: 'status',
                        status: 'running',
                        progress: 0.5
                    }
                }));

                // Emit log: starting task
                setTimeout(() => {
                    statusListeners.forEach((fn: Function) => fn({
                        payload: {
                            type: 'log',
                            message: 'ğŸ“‹ æ­£åœ¨è¯»å– Demo Proposal...'
                        }
                    }));
                }, 300);

                // Emit log: creating files
                setTimeout(() => {
                    statusListeners.forEach((fn: Function) => fn({
                        payload: {
                            type: 'log',
                            message: 'ğŸ“ æ­£åœ¨åˆ›å»º src/views/Login.vue...'
                        }
                    }));
                }, 800);

                setTimeout(() => {
                    statusListeners.forEach((fn: Function) => fn({
                        payload: {
                            type: 'log',
                            message: 'ğŸ“ æ­£åœ¨åˆ›å»º src/router/index.ts...'
                        }
                    }));
                }, 1300);

                setTimeout(() => {
                    statusListeners.forEach((fn: Function) => fn({
                        payload: {
                            type: 'log',
                            message: 'ğŸ§ª æ­£åœ¨åˆ›å»º tests/e2e/demo-login.spec.ts...'
                        }
                    }));
                }, 1800);

                // Emit final result
                setTimeout(() => {
                    const finalResult = 'âœ… **Demo åº”ç”¨åˆ›å»ºæˆåŠŸï¼**\n\nğŸ“ **å·²åˆ›å»ºæ–‡ä»¶ï¼š**\n- `src/views/Login.vue` - ç™»å½•ç»„ä»¶ï¼ˆVue 3 Composition APIï¼‰\n- `src/router/index.ts` - è·¯ç”±é…ç½®\n- `tests/e2e/demo-login.spec.ts` - E2E æµ‹è¯•\n\nğŸ¯ **ä¸‹ä¸€æ­¥ï¼š**\n1. è¿è¡Œ `npm install` å®‰è£…ä¾èµ–\n2. è¿è¡Œ `npm run dev` å¯åŠ¨å¼€å‘æœåŠ¡å™¨\n3. è®¿é—® http://localhost:5173/login æŸ¥çœ‹ç™»å½•é¡µé¢\n4. è¿è¡Œ `npm run test:e2e` æ‰§è¡Œæµ‹è¯•\n\nğŸ’¡ **æç¤ºï¼š** è¿™æ˜¯ä¸€ä¸ªæ¼”ç¤ºåº”ç”¨ï¼Œå±•ç¤ºäº†å¦‚ä½•ä½¿ç”¨ IfAI åˆ›å»ºå®Œæ•´çš„ Vue ç™»å½•åŠŸèƒ½ã€‚\n\nï¼ˆæ³¨ï¼šè¿™æ˜¯ E2E æµ‹è¯•ç¯å¢ƒçš„æ¨¡æ‹Ÿè¾“å‡ºï¼ŒçœŸå®ç¯å¢ƒä¸­ä¼šå®é™…åˆ›å»ºæ–‡ä»¶ï¼‰';

                    // Emit status: completed
                    statusListeners.forEach((fn: Function) => fn({
                        payload: {
                            type: 'status',
                            status: 'completed',
                            progress: 1.0
                        }
                    }));

                    // Emit result
                    setTimeout(() => {
                        statusListeners.forEach((fn: Function) => fn({
                            payload: {
                                type: 'result',
                                result: finalResult
                            }
                        }));
                    }, 100);
                }, 2500);
            }, 500);

            return { success: true, agent_id: agentId };
        }

        if (cmd === 'ai_chat') {
            // Mock streaming response that sends content and triggers _finish event
            const eventId = args?.event_id || 'mock-event-id';
            const messages = args?.messages || [];
            const lastUserMsg = [...messages].reverse().find(m => m.role === 'user');
            const query = lastUserMsg?.content?.Text || lastUserMsg?.content || '';

            // Check if this is a bash command request
            const isBashCommand = query.includes('æ‰§è¡Œ') || query.includes('è¿è¡Œ') ||
                                 query.includes('python') || query.includes('java') ||
                                 query.includes('curl') || query.includes('whoami') ||
                                 query.includes('sleep') || query.includes('git') ||
                                 query.includes('npm') || query.includes('cargo');

            let responseContent = 'Mock AI response: Task completed successfully.';

            // Simulate async streaming
            setTimeout(() => {
                const streamListeners = (window as any).__TAURI_EVENT_LISTENERS__[eventId] || [];

                if (isBashCommand) {
                    // Simulate tool_calls for bash commands
                    const toolCallPayload = JSON.stringify({
                        choices: [{
                            index: 0,
                            delta: {
                                tool_calls: [{
                                    index: 0,
                                    id: 'call_bash_mock',
                                    type: 'function',
                                    function: {
                                        name: 'bash',
                                        arguments: JSON.stringify({
                                            command: query.replace(/^(å¸®æˆ‘)?(æ‰§è¡Œ|è¿è¡Œ)\s+/, ''),
                                            timeout: 30000
                                        })
                                    }
                                }]
                            }
                        }]
                    });

                    streamListeners.forEach(fn => fn({ payload: toolCallPayload }));

                    // After tool call, send the result
                    setTimeout(() => {
                        // Generate mock command output
                        let mockOutput = '';
                        if (query.includes('python')) mockOutput = 'Python 3.11.0';
                        else if (query.includes('java')) mockOutput = 'openjdk version "17.0.2"';
                        else if (query.includes('curl')) mockOutput = 'HTTP/1.1 200 OK';
                        else if (query.includes('whoami')) mockOutput = 'mock-user';
                        else if (query.includes('sleep')) mockOutput = 'Command completed';
                        else if (query.includes('git')) mockOutput = 'git version 2.39.0';
                        else mockOutput = 'Command executed successfully';

                        const contentPayload = JSON.stringify({
                            choices: [{
                                index: 0,
                                delta: { content: mockOutput }
                            }]
                        });

                        streamListeners.forEach(fn => fn({ payload: contentPayload }));

                        // Trigger _finish event
                        setTimeout(() => {
                            const finishListeners = (window as any).__TAURI_EVENT_LISTENERS__[`${eventId}_finish`] || [];
                            finishListeners.forEach(fn => fn({ payload: 'DONE' }));
                        }, 50);
                    }, 200);
                } else {
                    // Regular response for non-bash commands
                    streamListeners.forEach(fn => fn({ payload: responseContent }));

                    // Trigger _finish event shortly after
                    setTimeout(() => {
                        const finishListeners = (window as any).__TAURI_EVENT_LISTENERS__[`${eventId}_finish`] || [];
                        finishListeners.forEach(fn => fn({ payload: 'DONE' }));
                    }, 50);
                }
            }, 100);
            return {};
        }
        return {};
    };

    const mockListen = async (event: string, handler: Function) => {
        const listeners = (window as any).__TAURI_EVENT_LISTENERS__[event] || [];
        listeners.push(handler);
        (window as any).__TAURI_EVENT_LISTENERS__[event] = listeners;
        return () => {
            const idx = (window as any).__TAURI_EVENT_LISTENERS__[event]?.indexOf(handler);
            if (idx > -1) (window as any).__TAURI_EVENT_LISTENERS__[event]?.splice(idx, 1);
        };
    };

    // ğŸ”¥ Mock Tauri app API
    const mockApp = {
        getName: async () => 'IfAI',
        getVersion: async () => '0.2.6',
        getTauriVersion: async () => '1.5.0',
    };

    (window as any).__TAURI_INTERNALS__ = {
        transformCallback: (cb: any) => cb,
        invoke: mockInvoke,
        // ğŸ”¥ Add unregisterCallback support
        unregisterCallback: (cb: any) => {
            // Mock implementation - do nothing
        }
    };
    (window as any).__TAURI__ = {
      core: { invoke: mockInvoke },
      event: {
        listen: mockListen,
        // ğŸ”¥ Add event.emit support
        emit: async (event: string, payload?: any) => {
            const listeners = (window as any).__TAURI_EVENT_LISTENERS__[event] || [];
            listeners.forEach((fn: Function) => fn({ payload }));
        }
      },
      // ğŸ”¥ Add app API
      app: mockApp,
      // ğŸ”¥ Mock window API for App.tsx initialization
      window: {
        getCurrent: () => ({
          show: async () => console.log('[E2E Mock] Window shown'),
          hide: async () => console.log('[E2E Mock] Window hidden'),
          close: async () => console.log('[E2E Mock] Window closed'),
          minimize: async () => console.log('[E2E Mock] Window minimized'),
          maximize: async () => console.log('[E2E Mock] Window maximized'),
          unmaximize: async () => console.log('[E2E Mock] Window unmaximized'),
          isFocused: async () => true,
          isMaximized: async () => false,
          isMinimized: async () => false,
          scaleFactor: async () => 1,
          innerPosition: async () => ({ x: 0, y: 0 }),
          innerSize: async () => ({ width: 1920, height: 1080 }),
          outerPosition: async () => ({ x: 0, y: 0 }),
          outerSize: async () => ({ width: 1920, height: 1080 }),
          setAlwaysOnTop: async () => {},
          setAlwaysOnBottom: async () => {},
          setDecorations: async () => {},
          setIgnoreCursorEvents: async () => {},
          setSize: async () => {},
          setMinSize: async () => {},
          setMaxSize: async () => {},
          setPosition: async () => {},
          setTitle: async () => {},
          setResizable: async () => {},
          setSkipTaskbar: async () => {},
          onFocusChanged: () => {},
          onResizeRequested: () => {},
          onCloseRequested: () => {},
          onScaleChanged: () => {},
        })
      }
    };

    // Mock proposal commands to auto-load v0.2.6-demo-vue-login
    const mockListProposals = async () => {
      const mockProposal = {
        proposals: [
          {
            id: 'v0.2.6-demo-vue-login',
            title: 'Demo Vue Login Feature',
            status: 'draft',
            location: 'proposals',
            created_at: Date.now(),
            updated_at: Date.now()
          }
        ],
        last_updated: Date.now() / 1000
      };
      return mockProposal;
    };

    const mockLoadProposal = async (args: any) => {
      if (args.id === 'v0.2.6-demo-vue-login') {
        // è¯»å–çœŸå®çš„ proposal æ–‡ä»¶
        const proposalData = {
          id: 'v0.2.6-demo-vue-login',
          path: '.ifai/proposals/v0.2.6-demo-vue-login/',
          status: 'draft',
          location: 'proposals',
          proposal_location: 'proposals',
          why: 'å®ç° Vue ç™»å½•åŠŸèƒ½æ¼”ç¤º',
          what_changes: ['æ·»åŠ ç™»å½•ç»„ä»¶', 'å®ç°è®¤è¯é€»è¾‘'],
          impact: {
            specs: [],
            files: [],
            breaking_changes: false
          },
          tasks: [],
          spec_deltas: [],
          design: null,
          created_at: Date.now(),
          updated_at: Date.now(),
          validated: false
        };
        return proposalData;
      }
      throw new Error('Proposal not found');
    };

    // Override mockInvoke for proposal commands
    const originalMockInvoke = mockInvoke;
    (window as any).__TAURI_INTERNALS__.invoke = async (cmd: string, args?: any) => {
      if (cmd === 'list_proposals') return await mockListProposals();
      if (cmd === 'load_proposal') return await mockLoadProposal(args);
      return originalMockInvoke(cmd, args);
    };

    // B. å¼ºåŠ›åŠ«æŒ LocalStorage é˜²æ­¢è¢« SettingsStore åˆå§‹åŒ–è¦†ç›–
    const providers = [{
        id: 'ollama-e2e', name: 'Ollama Mock', protocol: 'openai', 
        baseUrl: 'http://localhost:11434/v1/chat/completions', 
        apiKey: 'e2e-token', models: ['mock-model'], enabled: true
    }];
    
    const configurations: Record<string, any> = {
        'ifai_onboarding_state': { completed: true, skipped: true },
        'file-storage': { state: { rootPath: '/Users/mac/mock-project' }, version: 0 },
        'settings-storage': { state: { currentProviderId: 'ollama-e2e', currentModel: 'mock-model', providers }, version: 0 },
        'thread-storage': { state: { activeThreadId: 'e2e-thread-1', threads: [{ id: 'e2e-thread-1', messages: [] }] }, version: 0 },
        'layout-storage': { state: { isChatOpen: true, isSidebarOpen: true }, version: 0 }
    };

    const originalGetItem = window.localStorage.getItem.bind(window.localStorage);
    window.localStorage.getItem = (key: string) => {
        if (configurations[key]) return JSON.stringify(configurations[key]);
        return originalGetItem(key);
    };

    // C. æ³¨å…¥ä¸‡èƒ½åé—¨
    (window as any).__E2E_SEND__ = async (text: string) => {
        const store = (window as any).__chatStore?.getState();
        if (store) {
            console.log(`[E2E] Direct Store Send: ${text}`);
            await store.sendMessage(text, 'ollama-e2e', 'mock-model');
        }
    };

    // D. è‡ªåŠ¨åˆ·æ–° proposal ç´¢å¼•
    (window as any).__E2E_REFRESH_PROPOSALS__ = async () => {
        const proposalStore = (window as any).__proposalStore;
        if (proposalStore) {
            console.log('[E2E] Refreshing proposal index...');
            await proposalStore.getState().refreshIndex();
            console.log('[E2E] Proposal index refreshed:', proposalStore.getState().index);
        }
    };

    (window as any).__E2E_GET_MESSAGES__ = () => {
        return (window as any).__chatStore?.getState()?.messages || [];
    };

    (window as any).__E2E_OPEN_MOCK_FILE__ = (name: string, content?: string) => {
        const fileStore = (window as any).__fileStore?.getState();
        const fileContent = content || `
/**
 * Test class for breadcrumbs
 */
export class TestApp {
    private value: number = 0;

    constructor() {
        console.log("Initialized");
    }

    public getValue() {
        return this.value;
    }
}
                `;
        const filePath = `/Users/mac/mock-project/${name}`;

        if (fileStore) {
            fileStore.openFile({
                id: `mock-${name}`,
                path: filePath,
                name: name,
                content: fileContent,
                isDirty: false,
                language: 'typescript'
            });
            // Auto assign to active pane if possible
            const layoutStore = (window as any).__layoutStore?.getState();
            if (layoutStore && layoutStore.activePaneId) {
                layoutStore.assignFileToPane(layoutStore.activePaneId, `mock-${name}`);
            }
        }

        // ğŸ”¥ åˆå§‹åŒ– mock æ–‡ä»¶ç³»ç»Ÿï¼Œç¡®ä¿æ–‡ä»¶å­˜åœ¨
        const mockFileSystem = (window as any).__E2E_MOCK_FILE_SYSTEM__;
        if (mockFileSystem && !mockFileSystem.has(filePath)) {
            mockFileSystem.set(filePath, fileContent);
            console.log('[E2E Mock] Initialized file system with:', name);
        }
    };

    // E. Mock IndexedDB for thread persistence testing
    (window as any).__E2E_INDEXED_DB_MOCK__ = {
        threads: new Map<string, any>(),
        messages: new Map<string, any[]>(),

        clear() {
            this.threads.clear();
            this.messages.clear();
        },

        saveThread(thread: any) {
            this.threads.set(thread.id, thread);
        },

        getThread(threadId: string) {
            return this.threads.get(threadId);
        },

        getAllThreads() {
            return Array.from(this.threads.values());
        },

        saveMessages(messages: any[]) {
            messages.forEach(msg => {
                const threadMsgs = this.messages.get(msg.threadId) || [];
                threadMsgs.push(msg);
                this.messages.set(msg.threadId, threadMsgs);
            });
        },

        getThreadMessages(threadId: string) {
            return this.messages.get(threadId) || [];
        },

        deleteThread(threadId: string) {
            this.threads.delete(threadId);
            this.messages.delete(threadId);
        }
    };

    // æš´éœ²ä»»åŠ¡æ‹†è§£ Store
    const originalSetItem = window.localStorage.setItem.bind(window.localStorage);
    window.localStorage.setItem = (key, val) => {
        if (key === 'task-breakdown-storage') {
            console.log('[E2E] Intercepted Task Breakdown Store Save');
        }
        return originalSetItem(key, val);
    };

    // D. è¿è¡Œæ—¶çŠ¶æ€ç¨³å®šå™¨ (é˜²æ­¢ç»„ä»¶æŒ‚è½½åçš„çŠ¶æ€åç§»)
    setInterval(() => {
        if ((window as any).__E2E_SKIP_STABILIZER__) return;
        
        const settings = (window as any).__settingsStore?.getState();
        if (settings && settings.currentProviderId !== 'ollama-e2e') {
            settings.updateSettings({ currentProviderId: 'ollama-e2e', currentModel: 'mock-model' });
        }
        const file = (window as any).__fileStore?.getState();
        if (file && (!file.rootPath || !file.fileTree)) {
            console.log('[E2E Mock] Initializing FileStore state...');
            file.setRootPath('/Users/mac/mock-project');
            file.setFileTree({ 
                id: 'root', 
                name: 'mock-project', 
                kind: 'directory', 
                path: '/Users/mac/mock-project', 
                children: [
                    { id: 'app-tsx', name: 'App.tsx', kind: 'file', path: '/Users/mac/mock-project/App.tsx' },
                    { id: 'main-tsx', name: 'main.tsx', kind: 'file', path: '/Users/mac/mock-project/main.tsx' }
                ] 
            });
        }
    }, 1000);

    // E. è‡ªåŠ¨åˆ·æ–° proposal ç´¢å¼•ï¼ˆå»¶è¿Ÿæ‰§è¡Œï¼Œç¡®ä¿ store å·²åˆå§‹åŒ–ï¼‰
    setTimeout(async () => {
      try {
        const proposalStore = (window as any).__proposalStore;
        if (proposalStore) {
          console.log('[E2E] Auto-refreshing proposal index...');
          await proposalStore.getState().refreshIndex();
          console.log('[E2E] Proposal index refreshed:', proposalStore.getState().index);
        } else {
          console.warn('[E2E] Proposal store not found');
        }
      } catch (e) {
        console.error('[E2E] Failed to refresh proposal index:', e);
      }
    }, 500);

    // ğŸ”¥ å•†ä¸šç‰ˆï¼šç¡®ä¿ ifainew-core çš„ store è¢«æš´éœ²åˆ° window
    setTimeout(() => {
      if (!(window as any).__chatStore) {
        console.log('[E2E] __chatStore not found, attempting to set from module...');
        // å°è¯•ä»å…¨å±€ä½œç”¨åŸŸè·å– ifainew-core çš„ useChatStore
        try {
          // æ£€æŸ¥æ˜¯å¦å¯ä»¥é€šè¿‡ require/import è·å–
          const stores = (window as any).___stores___;
          if (stores && stores.useChatStore) {
            (window as any).__chatStore = stores.useChatStore;
            console.log('[E2E] __chatStore set from ___stores___');
          }
        } catch (e) {
          console.warn('[E2E] Could not set __chatStore:', e);
        }
      } else {
        console.log('[E2E] __chatStore already available');
      }
    }, 1000);
  });
}